# Фреймворк модулей SDevice

Фреймворк для создания универсальных модулей с единым расширяемым интерфейсом. Также предоставляет способ логирования, проверки утверждений (assertions) и обработки исключений на основе библиотеки [CExceptions](https://github.com/ThrowTheSwitch/CException), включенной в качестве подмодуля. Основной механизм, используемый фреймворком - связывание на уровне имен, для чего используются макросы.

## Зависимости

* [CExceptions](https://gitlab.dnouglublenie.ru/nonius/embeddedfirmware/embeddedcommon/forks/cexception.git)

## Создание нового модуля

### Публичный интерфейс

Для определения публичного интерфейса используется заголовочный файл этой библиотеки `core.h`.

1. Модуль *может* определить свою версию, используя предопределенную структуру `SDeviceVersion`.
2. Модуль **обязан** предварительно объявить дескриптор `SDEVICE_HANDLE_FORWARD_DECLARATION()`.
3. Модуль *может* определить тип-перечисление, описывающий исключения, которые могут возникнуть в ходе его работы (значения должны быть приводимы к типу `int32_t`).
4. Модуль **обязан** определить тип-перечисление, описывающий состояния для логирования, которые могут возникнуть в ходе его работы (значения должны быть приводимы к типу `int32_t`).
5. Модуль **обязан** предварительно и полноценно объявить параметры инициализации дескриптора `SDEVICE_INIT_DATA_FORWARD_DECLARATION()` и `SDEVICE_INIT_DATA_DECLARATION()`.
6. Модуль *может* объявить функции создания и удаления дескриптора `SDEVICE_CREATE_HANDLE_DECLARATION()` и `SDEVICE_DISPOSE_HANDLE_DECLARATION()`.
7. Модуль *может* объявить обычные свойства для чтения и\или записи `SDEVICE_PROPERTY_TYPE_DECLARATION()`, `SDEVICE_GET_PROPERTY_DECLARATION()` и `SDEVICE_SET_PROPERTY_DECLARATION()`.
8. Модуль *может* объявить частичные свойства для чтения и\или записи `SDEVICE_PROPERTY_TYPE_DECLARATION()`, `SDEVICE_SET_PARTIAL_PROPERTY_DECLARATION()` и `SDEVICE_GET_PARTIAL_PROPERTY_DECLARATION()`.
9. Модуль *может* объявить прочие пользовательские функции.

### Приватный интерфейс

Для определения приватного интерфейса используется заголовочный файл публичного интерфейса.

1. Модуль **обязан** предварительно и полноценно объявить параметры времени выполнения дескриптора `SDEVICE_RUNTIME_DATA_FORWARD_DECLARATION()` и `SDEVICE_RUNTIME_DATA_DECLARATION()`.
2. Модуль **обязан** полноценно объявить дескриптор `SDEVICE_HANDLE_DECLARATION()`.
3. Модуль *может* объявить приватные псевдонимы для типов данных, используя макрос `SDEVICE_INTERNAL_ALIASES_DECLARATION()`.

### Реализация интерфейса

При реализации интерфейса используется заголовочный файл приватной его части (она уже включает в себя публичную).

1. Модуль *может* определить функции создания и удаления дескриптора `SDEVICE_CREATE_HANDLE_DECLARATION()` и `SDEVICE_DISPOSE_HANDLE_DECLARATION()`.
2. Модуль *может* определить обычные свойства для чтения и\или записи, используя макросы `SDEVICE_GET_PROPERTY_DECLARATION()` и `SDEVICE_SET_PROPERTY_DECLARATION()`.
3. Модуль *может* определить частичные свойства для чтения и\или записи, используя макросы `SDEVICE_SET_PARTIAL_PROPERTY_DECLARATION()` и `SDEVICE_GET_PARTIAL_PROPERTY_DECLARATION()`.
4. Модуль *может* определить прочие пользовательские функции.

## Обработка ошибок и логирование

Средства, используемые для обработки ошибок, проверки утверждений и логирования содержатся в заголовочном файле `errors.h`.

### Проверка утверждений (assertions)

Для проверки утверждений используются два макроса:

* `SDeviceAssert()` - для проверки значений, передаваемых пользователем модуля
* `SDeviceDebugAssert()` - для проверки внутренних значений модуля

Такое разделение позволит сократить объем кода в отладочной версии конечного приложения, отключив проверку утверждений, переданных в `SDeviceDebugAssert()`. В оптимизированной же версии конечного приложения имеет смысл полностью отключить проверку утверждений.

### Логирование

Логирование состояний происходит с помощью макроса `SDeviceLogStatus()`. Данный макрос вызывает процедуру `SDeviceProcessLogStatus()`, которая определена в виде слабого символа.

### Обработка исключений

Для обработки исключений используются средства библиотеки `CExceptions`, а также макрос `SDeviceThrow()`.
В случае, если исключение не было обработано, произойдет вызов процедуры `SDeviceProcessUnhandledThrow()`, которая определена в виде слабого символа.

## Динамическое выделение памяти

При создании (и удалении) экземпляров модулей используются механизм динамического выделения памяти, реализованный процедурами `SDeviceMalloc()` и `SDeviceFree()`. Обе процедуры определены в виде слабых символов.
